====================
PyPy without the GIL
====================

Intro
---------------------------

- PyPy intro

- thanks to contributors for STM


Problem
-------

* An existing complex, large program that does stuff

* "stuff" consists of bits that are mostly independent from each other

|pause|

* ... but not quite


Problem
-------

* We want to parallelize the program to use all these cores

* We have some shared mutable state

|pause|

* Not too much of it --- otherwise, no chance for parallelism

* But still some


Classic solutions
-----------------

Bare-metal multi-threading:

* large shared state

* needs careful usage of locks

* mostly hindered by the GIL in CPython
  (but not in Jython)


Classic solutions
-----------------

Multi-processing:

* no shared mutable state at all

* copying, keeping in sync are your problem

* memory usage is often multiplied (unless you're lucky with ``fork``)


Classic solutions
-----------------

A range of intermediate solutions:

* MPI: message passing, with limited shared state

* etc.: tons of experiments that never caught on


Classic solutions
-----------------

The typical solution for web servers:

* run independent processes

* share data only via the database

* the database itself handles concurrency with transactions


Demo
---------------------------

* ``pypy-stm``

* internally based on "transactions" (STM, HTM)


Demo
---------------------------

- demo: 

  * multithreading.py

  * multithreading2.py

  * message_passing.py

  * transactions2.py



- missing in pypy-stm:

  * GC major collection
  * JIT
  * some more optimizations possible (= tons of)


- __pypy__.thread.atomic

  * with atomic:
        print "hello", username

  * the illusion of serialization


Lower level: STM
---------------------------

- pypy and not cpython?


- STM = Software Transactional Memory


- Basic idea: each thread runs in parallel, but everything it does is
  in a series of "transactions"


- A transaction keeps all changes to pre-existing memory "local"


- The changes are made visible only when the transaction "commits"


- The transaction will "abort" if a conflict is detected, and
  it will be transparently retried


- Non-reversible operations like I/O turn the transaction "inevitable"
  and stop progress in the other threads


- __pypy__.thread.last_abort_info() -> traceback-like information


- (GC-supported structure: when we want to modify a pre-existing object,
  we first copy it into "local" memory, and when we commit, it becomes
  the newer version of the old pre-existing object; we end up with a
  chained list of versions, and we have to make sure we always use the
  latest one.  We rely on GC major collections to free them eventually.)


- alternative: HTM...?


Higher level: not threads
---------------------------


- xxx memory usage good


- based on (and fully compatible with) threads

  * existing multithreaded programs work


- but opens up unexpected alternatives

  * we can run multiple threads but at the same time use ``atomic``

  * with the GIL-based idea of ``atomic`` it doesn't make sense:
    we have multiple threads but they're all using ``atomic``, i.e.
    only one at a time will ever run...  except no :-)


- transaction.py

  * demo

  * illusion of serial execution: can "sanely" reason about algorithms

  * "Conflict tracebacks"

  * Might need to debug them --- but they are performance bugs, not
    correctness bugs

  * The idea is that we fix only XX% of the bugs and we are done

  * Maybe some new "performance debugger" tools might help too


- TigerQuoll, 1st March: same idea with JavaScript (for servers)

  * various models possible:

    . events dispatchers

    . futures

    . map/reduce, scatter/gather


- Event dispatchers

  * twisted, tulip, etc.

  * run the event dispatcher in one thread (e.g. the main thread),
    and schedule the actual events to run on a different thread from
    a pool

  * the events are run with ``atomic``, so that they appear to run
    serially

  * does not rely on any change to the user program
