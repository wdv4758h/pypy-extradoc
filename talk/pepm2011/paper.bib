
@article{choi_escape_1999,
	title = {Escape analysis for {J}ava},
	volume = {34},
	url = {http://portal.acm.org/citation.cfm?id=320386},
	doi = {10.1145/320385.320386},
	abstract = {This paper presents a simple and efficient data flow algorithm for escape analysis of objects in Java programs to determine (i) if an object can be allocated on the stack; (ii) if an object is accessed only by a single thread during its lifetime, so that synchronization operations on that object can be removed. We introduce a new program abstraction for escape analysis, the connection graph, that is used to establish reachability relationships between objects and object references. We show that the connection graph can be summarized for each method such that the same summary information may be used effectively in different calling contexts. We present an interprocedural algorithm that uses the above property to efficiently compute the connection graph and identify the non-escaping objects for methods and threads. The experimental results, from a prototype implementation of our framework in the {IBM} High Performance Compiler for Java, are very promising. The percentage of objects that may be allocated on the stack exceeds 70\% of all dynamically created objects in three out of the ten benchmarks (with a median of 19\%), 11\% to 92\% of all lock operations are eliminated in those ten programs (with a median of 51\%), and the overall execution time reduction ranges from 2\% to 23\% (with a median of 7\%) on a 333 {MHz} {PowerPC} workstation with 128 {MB} memory.},
	number = {10},
	journal = {{SIGPLAN} Not.},
	author = {{Jong-Deok} Choi and Manish Gupta and Mauricio Serrano and Vugranam C. Sreedhar and Sam Midkiff},
	year = {1999},
	pages = {1--19}
},

@article{park_escape_1992,
	title = {Escape analysis on lists},
	volume = {27},
	url = {http://portal.acm.org/citation.cfm?id=143125},
	doi = {10.1145/143103.143125},
	abstract = {Higher order functional programs constantly allocate objects dynamically. These objects are typically cons cells, closures, and records and are generally allocated in the heap and reclaimed later by some garbage collection process. This paper describes a compile time analysis, called escape analysis, for determining the lifetime of dynamically created objects in higher order functional programs, and describes optimizations that can be performed, based on the analysis, to improve storage allocation and reclamation of such objects. In particular, our analysis can be applied to programs manipulating lists, in which case optimizations can be performed to allow cons cells in spines of lists to be either reclaimed immediately or reused without incurring any garbage collection overhead. In a previous paper on escape analysis [10], we had left open the problem of performing escape analysis on lists. Escape analysis simply determines when the argument (or some part of the argument) to a function call is returned by that call. This simple piece of information turns out to be sufficiently powerful to allow stack allocation of objects, compile-time garbage collection, reduction of run-time storage reclamation overhead, and other optimizations that are possible when the lifetimes of objects can be computed statically. Our approach is to define a high-level non-standard semantics that, in many ways, is similar to the standard semantics and captures the escape behavior caused by the constructs in a functional language. The advantage of our analysis lies in its conceptual simplicity and portability (i.e. no assumption is made about an underlying abstract machine).},
	number = {7},
	journal = {{SIGPLAN} Not.},
	author = {Young Gil Park and Benjamin Goldberg},
	year = {1992},
	pages = {116--127}
},

@inproceedings{goldberg_higher_1990,
	address = {Copenhagen, Denmark},
	title = {Higher order escape analysis: optimizing stack allocation in functional program implementations},
	isbn = {0-387-52592-0},
	shorttitle = {Higher order escape analysis},
	url = {http://portal.acm.org/citation.cfm?id=92025},
	booktitle = {Proceedings of the third European symposium on programming on {ESOP} '90},
	publisher = {{Springer-Verlag} New York, Inc.},
	author = {B. Goldberg and Y. G. Park},
	year = {1990},
	pages = {152--160}
},

@misc{_property_????,
	title = {Property cache - {MDC}},
	url = {https://developer.mozilla.org/en/SpiderMonkey/Internals/Property_cache},
	howpublished = {{https://developer.mozilla.org/en/SpiderMonkey/Internals/Property\_cache}}
},

@incollection{bruni_pygirl:_2009,
	series = {Lecture Notes in Business Information Processing},
	title = {{PyGirl:} Generating {Whole-System} {VMs} from {High-Level} Prototypes Using {PyPy}},
	volume = {33},
	isbn = {978-3-642-02571-6},
	url = {http://dx.doi.org/10.1007/978-3-642-02571-6_19},
	booktitle = {Objects, Components, Models and Patterns},
	publisher = {Springer Berlin Heidelberg},
	author = {Camillo Bruni and Toon Verwaest},
	editor = {Will Aalst and John Mylopoulos and Norman M Sadeh and Michael J Shaw and Clemens Szyperski and Manuel Oriol and Bertrand Meyer},
	year = {2009},
	note = {10.1007/978-3-642-02571-6\_19},
	pages = {328--347}
},

@article{bruno_blanchet_escape_2003,
	title = {Escape analysis for {J}ava: Theory and practice},
	volume = {25},
	shorttitle = {Escape analysis for {Java{\textless}sup{\textgreater}TM{\textless}/sup{\textgreater}}},
	url = {http://portal.acm.org/citation.cfm?id=945885.945886},
	doi = {10.1145/945885.945886},
	abstract = {Escape analysis is a static analysis that determines whether the lifetime of data may exceed its static {scope.This} paper first presents the design and correctness proof of an escape analysis for {JavaTM.} This analysis is interprocedural, context sensitive, and as flow-sensitive as the static single assignment form. So, assignments to object fields are analyzed in a flow-insensitive manner. Since Java is an imperative language, the effect of assignments must be precisely determined. This goal is achieved thanks to our technique using two interdependent analyses, one forward, one backward. We introduce a new method to prove the correctness of this analysis, using aliases as an intermediate step. We use integers to represent the escaping parts of values, which leads to a fast and precise {analysis.Our} implementation {[Blanchet} 1999], which applies to the whole Java language, is then presented. Escape analysis is applied to stack allocation and synchronization elimination. In our benchmarks, we stack allocate 13\% to 95\% of data, eliminate more than 20\% of synchronizations on most programs (94\% and 99\% on two examples) and get up to 43\% runtime decrease (21\% on average). Our detailed experimental study on large programs shows that the improvement comes more from the decrease of the garbage collection and allocation times than from improvements on data locality, contrary to what happened for {ML.} This comes from the difference in the garbage collectors.},
	number = {6},
	journal = {{ACM} Trans. Program. Lang. Syst.},
	author = {Bruno Blanchet},
	year = {2003},
	pages = {713--775}
},

@incollection{mazur_practical_2001,
	series = {Lecture Notes in Computer Science},
	title = {Practical Aspects for a Working Compile Time Garbage Collection System for {M}ercury},
	volume = {2237},
	url = {http://dx.doi.org/10.1007/3-540-45635-X_15},
	abstract = {Compile-time garbage collection {(CTGC)} is still a very uncommon feature within compilers. In previous work we have developed a compile-time structure reuse system for Mercury, a logic programming language. This system indicates which datastructures can safely be reused at run-time. As preliminary experiments were promising, we have continued this work and have now a working and well performing near-to-ship {CTGC-system} built into the Melbourne Mercury Compiler {(MMC).} In this paper we present the multiple design decisions leading to this system, we report the results of using {CTGC} for a set of benchmarks, including a real-world program, and finally we discuss further possible improvements. Benchmarks show substantial memory savings and a noticeable reduction in execution time.},
	booktitle = {Logic Programming},
	publisher = {Springer Berlin / Heidelberg},
	author = {Nancy Mazur and Peter Ross and Gerda Janssens and Maurice Bruynooghe},
	editor = {Philippe Codognet},
	year = {2001},
	note = {{10.1007/3-540-45635-X\_15}},
	pages = {105--119}
},

@article{lloyd_partial_1991,
	title = {Partial evaluation in logic programming},
	volume = {11},
	url = {http://portal.acm.org/citation.cfm?id=118495},
	number = {3-4},
	journal = {J. Log. Program.},
	author = {J. W. Lloyd and J. C. Shepherdson},
	year = {1991},
	pages = {217--242}
},

@phdthesis{cuni_high_2010,
	title = {High performance implementation of {P}ython for {CLI/.NET} with {JIT} compiler generation for dynamic languages.},
	school = {Dipartimento di Informatica e Scienze {dell'Informazione,} University of Genova},
	author = {Antonio Cuni},
	year = {2010},
	note = {Technical Report {DISI-TH-2010-05}}
},

@inproceedings{carl_friedrich_bolz_towards_2010,
	address = {Hagenberg, Austria},
	title = {Towards a Jitting {VM} for {P}rolog execution},
	isbn = {978-1-4503-0132-9},
	url = {http://portal.acm.org/citation.cfm?id=1836102},
	doi = {10.1145/1836089.1836102},
	abstract = {Most Prolog implementations are implemented in low-level languages such as C and are based on a variation of the {WAM} instruction set, which enhances their performance but makes them hard to write. In addition, many of the more dynamic features of Prolog (like assert), despite their popularity, are not well supported. We present a high-level continuation-based Prolog interpreter based on the {PyPy} project. The {PyPy} project makes it possible to easily and efficiently implement dynamic languages. It provides tools that automatically generate a just-in-time compiler for a given interpreter of the target language, by using partial evaluation techniques. The resulting Prolog implementation is surprisingly efficient: it clearly outperforms existing interpreters of Prolog in high-level languages such as Java. Moreover, on some benchmarks, our system outperforms state-of-the-art {WAM-based} Prolog implementations. Our paper aims to show that declarative languages such as Prolog can indeed benefit from having a just-in-time compiler and that {PyPy} can form the basis for implementing programming languages other than Python.},
	booktitle = {Proceedings of the 12th international {ACM} {SIGPLAN} symposium on Principles and practice of declarative programming},
	publisher = {{ACM}},
	author = {Carl Friedrich Bolz and Michael Leuschel and David Schneider},
	year = {2010},
	pages = {99--108}
},

@inproceedings{mogensen_constructor_1993,
	address = {Copenhagen, Denmark},
	title = {Constructor specialization},
	isbn = {0-89791-594-1},
	url = {http://portal.acm.org/citation.cfm?id=154633},
	doi = {10.1145/154630.154633},
	abstract = {In the section on “challenging problems” in the proceedings from the first international workshop on partial evaluation and mixed computation {[BEJ88]} a question is stated: {“Can} {PE} be used to generate new specialized data types, in a way analogous to generating specialized functions”. Since then little has been done to address this problem. In {[Lau89],} new types are indeed generated, but they are all simpler versions of the types in the original program. It is, e.g. not possible to have types with more constructors than the types in the original program. I propose to alleviate this by means of constructor specialization. Constructors are specialized with respect to the static parts of their arguments, just like residual functions. I show how this is done and argue that it makes it possible to get good results from partial evaluation in cases where the traditional methods fail to produce satisfactory results. The discussion is centered around a small subset of Standard {ML,} but the idea applies equally well to other languages having user defined constructors, e.g. Haskell and Prolog.},
	booktitle = {Proceedings of the 1993 {ACM} {SIGPLAN} symposium on Partial evaluation and semantics-based program manipulation},
	publisher = {{ACM}},
	author = {Torben Mogensen},
	year = {1993},
	pages = {22--32}
},

@inproceedings{bebenita_spur:_2010,
	address = {{Reno/Tahoe,} Nevada, {USA}},
	title = {{SPUR:} a trace-based {JIT} compiler for {CIL}},
	isbn = {978-1-4503-0203-6},
	shorttitle = {{SPUR}},
	url = {http://portal.acm.org/citation.cfm?id=1869459.1869517&coll=GUIDE&dl=GUIDE&type=series&idx=SERIES318&part=series&WantType=Proceedings&title=OOPSLA%2FSPLASH&CFID=106280261&CFTOKEN=29377718},
	doi = {10.1145/1869459.1869517},
	abstract = {Tracing just-in-time compilers {(TJITs)} determine frequently executed traces (hot paths and loops) in running programs and focus their optimization effort by emitting optimized machine code specialized to these traces. Prior work has established this strategy to be especially beneficial for dynamic languages such as {JavaScript,} where the {TJIT} interfaces with the interpreter and produces machine code from the {JavaScript} trace.},
	booktitle = {Proceedings of the {ACM} international conference on Object oriented programming systems languages and applications},
	publisher = {{ACM}},
	author = {Michael Bebenita and Florian Brandner and Manuel Fahndrich and Francesco Logozzo and Wolfram Schulte and Nikolai Tillmann and Herman Venter},
	year = {2010},
	pages = {708--725}
},

@inproceedings{wadler_deforestation:_1988,
	address = {Amsterdam, The Netherlands, The Netherlands},
	title = {Deforestation: transforming programs to eliminate trees},
	location = {Nancy, France},
	url = {http://portal.acm.org/citation.cfm?id=80098.80104},
	booktitle = {Proceedings of the Second European Symposium on Programming},
	publisher = {{North-Holland} Publishing Co.},
	author = {Philip Wadler},
	year = {1988},
	pages = {231{\textendash}248}
},

@inproceedings{gill_short_1993,
	address = {New York, {NY,} {USA}},
	series = {{FPCA} '93},
	title = {A short cut to deforestation},
	isbn = {{0-89791-595-X}},
	location = {Copenhagen, Denmark},
	url = {http://doi.acm.org/10.1145/165180.165214},
	doi = {http://doi.acm.org/10.1145/165180.165214},
	booktitle = {Proceedings of the conference on Functional programming languages and computer architecture},
	publisher = {{ACM}},
	author = {Andrew Gill and John Launchbury and Simon L Peyton Jones},
	year = {1993},
	pages = {223{\textendash}232}
},

@phdthesis{jrgensen_calculus_1996,
	type = {{Ph.D. Thesis}},
	title = {A Calculus for Boxing Analysis of Polymorphically Typed Languages},
	abstract = {An important decision when implementing languages with polymorphic types, such as Standard {ML} or Haskell, is whether to represent data in boxed or unboxed form and when to transform them from one representation to the other. Using a language with explicit representation types and boxing/unboxing operations we axiomatize equationally the set of all explicitly boxed versions, called completions, of a given source program. In a two-stage process we give some of the equations a rewriting interpretation that captures eliminating boxing/unboxing operations without relying on a specific implementation or even the semantics of the underlying language. The resulting reduction systems operate on congruence classes of completions defined by the remaining equations E, which can be understood as moving boxing/unboxing operations along data flow paths in the source program. We call a completion e formally optimal if every other completion for the same program (and at the same representation type) reduces to e under this two-stage reduction. We show that every source program has formally optimal completions, which are unique modulo E. This is accomplished by first "polarizing" the equations in E and orienting them to obtain two canonical (confluent and strongly normalizing) rewriting systems.},
	school = {University of Copenhapen},
	author = {Jesper J{\o}rgensen},
	year = {1996},
	note = {TR {96/28}}
},

@inproceedings{chang_tracing_2009,
	address = {Washington, {DC,} {USA}},
	title = {Tracing for Web 3.0: Trace Compilation for the Next Generation Web Applications},
	isbn = {978-1-60558-375-4},
	shorttitle = {Tracing for web 3.0},
	url = {http://portal.acm.org/citation.cfm?id=1508293.1508304},
	doi = {10.1145/1508293.1508304},
	abstract = {Today's web applications are pushing the limits of modern web browsers. The emergence of the browser as the platform of choice for rich client-side applications has shifted the use of in-browser {JavaScript} from small scripting programs to large computationally intensive application logic. For many web applications, {JavaScript} performance has become one of the bottlenecks preventing the development of even more interactive client side applications. While traditional just-in-time compilation is successful for statically typed virtual machine based languages like Java, compiling {JavaScript} turns out to be a challenging task. Many {JavaScript} programs and scripts are short-lived, and users expect a responsive browser during page loading. This leaves little time for compilation of {JavaScript} to generate machine code.},
	booktitle = {Proceedings of the 2009 {ACM} {SIGPLAN/SIGOPS} International Conference on Virtual Execution Environments},
	publisher = {{ACM}},
	author = {Mason Chang and Edwin Smith and Rick Reitmaier and Michael Bebenita and Andreas Gal and Christian Wimmer and Brendan Eich and Michael Franz},
	year = {2009},
	pages = {71--80}
},

@inproceedings{davide_ancona_rpython:_2007,
	address = {Montreal, Quebec, Canada},
	title = {{RPython:} a step towards reconciling dynamically and statically typed {OO} languages},
	isbn = {978-1-59593-868-8},
	shorttitle = {{RPython}},
	url = {http://portal.acm.org/citation.cfm?id=1297091},
	doi = {10.1145/1297081.1297091},
	abstract = {Although the C-based interpreter of Python is reasonably fast, implementations on the {CLI} or the {JVM} platforms offers some advantages in terms of robustness and interoperability. Unfortunately, because the {CLI} and {JVM} are primarily designed to execute statically typed, object-oriented languages, most dynamic language implementations cannot use the native bytecodes for common operations like method calls and exception handling; as a result, they are not able to take full advantage of the power offered by the {CLI} and {JVM.}},
	booktitle = {Proceedings of the 2007 symposium on Dynamic languages},
	publisher = {{ACM}},
	author = {Davide Ancona and Massimo Ancona and Antonio Cuni and Nicholas D. Matsakis},
	year = {2007},
	pages = {53--64}
},

@article{futamura_partial_1999,
	title = {Partial Evaluation of Computation Process - An Approach to a Compiler-Compiler},
	volume = {12},
	url = {http://citeseer.ist.psu.edu/futamura99partial.html},
	number = {4},
	journal = {{Higher-Order} and Symbolic Computation},
	author = {Yoshihiko Futamura},
	year = {1999},
	pages = {381--391},
},

@book{jones_partial_1993,
	title = {Partial evaluation and automatic program generation},
	isbn = {0-13-020249-5},
	url = {http://portal.acm.org/citation.cfm?id=153676},
	abstract = {This book is out of print. For copies, Please refer to the following online page},
	publisher = {{Prentice-Hall,} Inc.},
	author = {Neil D. Jones and Carsten K. Gomard and Peter Sestoft},
	year = {1993}
},

@inproceedings{armin_rigo_pypys_2006,
	address = {Portland, Oregon, {USA}},
	title = {{PyPy's} approach to virtual machine construction},
	isbn = {{1-59593-491-X}},
	url = {http://portal.acm.org/citation.cfm?id=1176753},
	doi = {10.1145/1176617.1176753},
	abstract = {The {PyPy} project seeks to prove both on a research and a practical level the feasibility of constructing a virtual machine {(VM)} for a dynamic language in a dynamic language - in this case, Python. The aim is to translate (i.e. compile) the {VM} to arbitrary target environments, ranging in level from {C/Posix} to {Smalltalk/Squeak} via Java and {CLI/.NET,} while still being of reasonable efficiency within these {environments.A} key tool to achieve this goal is the systematic reuse of the Python language as a system programming language at various levels of our architecture and translation process. For each level, we design a corresponding type system and apply a generic type inference engine - for example, the garbage collector is written in a style that manipulates simulated pointer and address objects, and when translated to C these operations become C-level pointer and address instructions.},
	booktitle = {Companion to the 21st {ACM} {SIGPLAN} conference on Object-oriented programming systems, languages, and applications},
	publisher = {{ACM}},
	author = {Armin Rigo and Samuele Pedroni},
	year = {2006},
	pages = {944--953}
},

@article{blanchet_escape_1999,
	title = {Escape Analysis for Object Oriented Languages. Application to {J}ava},
	url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.47.2277},
	doi = {10.1.1.47.2277},
	journal = {In Proceedings of the 14th Annual Conference on {Object-Oriented} Programming Systems, Languages and Applications},
	author = {Bruno Blanchet},
	year = {1999},
	pages = {20---34}
},

@article{georges_statistically_2007,
	title = {Statistically rigorous {J}ava performance evaluation},
	volume = {42},
	url = {http://portal.acm.org/citation.cfm?id=1297105.1297033},
	doi = {10.1145/1297105.1297033},
	abstract = {Java performance is far from being trivial to benchmark because it is affected by various factors such as the Java application, its input, the virtual machine, the garbage collector, the heap size, etc. In addition, non-determinism at run-time causes the execution time of a Java program to differ from run to run. There are a number of sources of non-determinism such as {Just-In-Time} {(JIT)} compilation and optimization in the virtual machine {(VM)} driven by timer-based method sampling, thread scheduling, garbage collection, and various.},
	number = {10},
	journal = {{SIGPLAN} Not.},
	author = {Andy Georges and Dries Buytaert and Lieven Eeckhout},
	year = {2007},
	pages = {57--76},
},

@techreport{miranda_context_1999,
	title = {Context Management in {VisualWorks} 5i},
	abstract = {Smalltalk-80 provides a reification of execution state in the form of context objects which represent procedure activation records. Smalltalk-80 also provides full closures with indefinite extent. These features pose interesting implementation challenges because a naïve implementation entails instantiating context objects on every method activation, but typical Smalltalk-80 programs obey stack discipline for the vast majority of activations. Both software and hardware implementations of Smalltalk-80 have mapped contexts and closure activations to stack frames but not without overhead when compared to traditional stack-based activation and return in “conventional” languages. We present a new design for contexts and closures that significantly reduces the overall overhead of these features and imposes overhead only in code that actually manipulates execution state in the form of contexts.},
	institution = {{ParcPlace} Division, {CINCOM,} Inc.},
	author = {Eliot Miranda},
	year = {1999},
},

@inproceedings{andreas_gal_trace-based_2009,
	title = {Trace-based Just-in-Time Type Specialization for Dynamic Languages},
	booktitle = {{PLDI}},
	author = {Andreas Gal and Brendan Eich and Mike Shaver and David Anderson and Blake Kaplan and Graydon Hoare and David Mandelin and Boris Zbarsky and Jason Orendorff and Michael Bebenita and Mason Chang and Michael Franz and Edwin Smith and Rick Reitmaier and Mohammad Haghighat},
	year = {2009},
},

@inproceedings{bolz_tracing_2009,
	address = {Genova, Italy},
	title = {Tracing the meta-level: {PyPy's} tracing {JIT} compiler},
	isbn = {978-1-60558-541-3},
	shorttitle = {Tracing the meta-level},
	url = {http://portal.acm.org/citation.cfm?id=1565827},
	doi = {10.1145/1565824.1565827},
	abstract = {We attempt to apply the technique of Tracing {JIT} Compilers in the context of the {PyPy} project, i.e., to programs that are interpreters for some dynamic languages, including Python. Tracing {JIT} compilers can greatly speed up programs that spend most of their time in loops in which they take similar code paths. However, applying an unmodified tracing {JIT} to a program that is itself a bytecode interpreter results in very limited or no speedup. In this paper we show how to guide tracing {JIT} compilers to greatly improve the speed of bytecode interpreters. One crucial point is to unroll the bytecode dispatch loop, based on two kinds of hints provided by the implementer of the bytecode interpreter. We evaluate our technique by applying it to two {PyPy} interpreters: one is a small example, and the other one is the full Python interpreter.},
	booktitle = {Proceedings of the 4th workshop on the Implementation, Compilation, Optimization of {Object-Oriented} Languages and Programming Systems},
	publisher = {{ACM}},
	author = {Carl Friedrich Bolz and Antonio Cuni and Maciej Fijałkowski and Armin Rigo},
	year = {2009},
	pages = {18--25}
},

@techreport{mason_chang_efficient_2007,
	title = {Efficient Just-In-Time Execution of Dynamically Typed Languages
Via Code Specialization Using Precise Runtime Type Inference},
	abstract = {Dynamically typed languages such as {JavaScript} present a challenge to just-in-time compilers. In contrast to statically typed languages such as {JVML,} in which there are specific opcodes for common operations on primitive types (such as iadd for integer addition), all operations in dynamically typed language such as {JavaScript} are late-bound. Often enough, types cannot be inferred with certainty ahead of execution. As a result, just-in-time compilers for dynamically typed languages have tended to perform worse than their statically-typed counterparts. We present a new approach to compiling dynamically typed languages in which code traces observed during execution are dynamically specialized for each actually observed run-time type. For most benchmark programs, our prototype {JavaScript} virtual machine outperforms every other {JavaScript} platform known to us.},
	number = {{ICS-TR-07-10}},
	institution = {Donald Bren School of Information and Computer Science, University of California, Irvine},
	author = {Mason Chang and Michael Bebenita and Alexander Yermolovich and Andreas Gal and Michael Franz},
	year = {2007},
},

@article{bala_dynamo:_2000,
	title = {Dynamo: a transparent dynamic optimization system},
	volume = {35},
	shorttitle = {Dynamo},
	url = {http://citeseer.ist.psu.edu/bala00dynamo.html},
	number = {5},
	journal = {{ACM} {SIGPLAN} Notices},
	author = {Vasanth Bala and Evelyn Duesterwald and Sanjeev Banerjia},
	year = {2000},
	pages = {1--12}
},

@techreport{andreas_gal_incremental_2006,
	title = {Incremental Dynamic Code Generation with Trace Trees},
	abstract = {The unit of compilation for traditional just-in-time compilers is the method. We have explored trace-based compilation, in which the unit of compilation is a loop, potentially spanning multiple methods and even library code. Using a new intermediate representation that is discovered and updated lazily on-demand while the program is being executed, our compiler generates code that is competitive with traditional dynamic compilers, but that uses only a fraction of the compile time and memory footprint.},
	number = {{ICS-TR-06-16}},
	institution = {Donald Bren School of Information and Computer Science, University of California, Irvine},
	author = {Andreas Gal and Michael Franz},
	month = nov,
	year = {2006},
	pages = {11}
},

@inproceedings{gal_hotpathvm:_2006,
	address = {Ottawa, Ontario, Canada},
	title = {{HotpathVM:} an effective {JIT} compiler for resource-constrained devices},
	isbn = {1-59593-332-6},
	shorttitle = {{HotpathVM}},
	url = {http://portal.acm.org/citation.cfm?doid=1134760.1134780},
	doi = {10.1145/1134760.1134780},
	abstract = {We present a just-in-time compiler for a Java {VM} that is small enough to fit on resource-constrained devices, yet is surprisingly effective. Our system dynamically identifies traces of frequently executed bytecode instructions (which may span several basic blocks across several methods) and compiles them via Static Single Assignment {(SSA)} construction. Our novel use of {SSA} form in this context allows to hoist instructions across trace side-exits without necessitating expensive compensation code in off-trace paths. The overall memory consumption (code and data) of our system is only 150 {kBytes,} yet benchmarks show a speedup that in some cases rivals heavy-weight just-in-time compilers.},
	booktitle = {Proceedings of the 2nd international conference on Virtual execution environments},
	publisher = {{ACM}},
	author = {Andreas Gal and Christian W. Probst and Michael Franz},
	year = {2006},
	pages = {144--153}
},

@article{chambers_efficient_1989,
	title = {An efficient implementation of {SELF} a dynamically-typed object-oriented language based on prototypes},
	volume = {24},
	url = {http://portal.acm.org/citation.cfm?id=74884},
	doi = {10.1145/74878.74884},
	abstract = {We have developed and implemented techniques that double the performance of dynamically-typed object-oriented languages. Our {SELF} implementation runs twice as fast as the fastest Smalltalk implementation, despite {SELF's} lack of classes and explicit variables. To compensate for the absence of classes, our system uses implementation-level maps to transparently group objects cloned from the same prototype, providing data type information and eliminating the apparent space overhead for prototype-based systems. To compensate for dynamic typing, user-defined control structures, and the lack of explicit variables, our system dynamically compiles multiple versions of a source method, each customized according to its receiver's map. Within each version the type of the receiver is fixed, and thus the compiler can statically bind and inline all messages sent to self. Message splitting and type prediction extract and preserve even more static type information, allowing the compiler to inline many other messages. Inlining dramatically improves performance and eliminates the need to hard-wire low-level methods such as +,==, and {ifTrue:.} Despite inlining and other optimizations, our system still supports interactive programming environments. The system traverses internal dependency lists to invalidate all compiled methods affected by a programming change. The debugger reconstructs inlined stack frames from compiler-generated debugging information, making inlining invisible to the {SELF} programmer.},
	number = {10},
	journal = {{SIGPLAN} Not.},
	author = {C. Chambers and D. Ungar and E. Lee},
	year = {1989},
	pages = {49--70},
},

@inproceedings{rigo_representation-based_2004,
	address = {Verona, Italy},
	title = {Representation-based just-in-time specialization and the {P}syco prototype for {P}ython},
	isbn = {1-58113-835-0},
	url = {http://portal.acm.org/citation.cfm?id=1014010},
	doi = {10.1145/1014007.1014010},
	abstract = {A powerful application of specialization is to remove interpretative overhead: a language can be implemented with an interpreter, whose performance is then improved by specializing it for a given program source. This approach is only moderately successful with very high level languages, where the operation of each single step can be highly dependent on run-time data and context. In the present paper, the Psyco prototype for the Python language is presented. It introduces two novel techniques. The first is just-in-time specialization, or specialization by need, which introduces the "unlifting" ability for a value to be promoted from run-time to compile-time during specialization -- the inverse of the lift operator of partial evaluation. Its presence gives an unusual and powerful perspective on the specialization process. The second technique is representations, a theory of data-oriented specialization generalizing the traditional specialization domains (i.e. the compile-time/run-time dichotomy).},
	booktitle = {Proceedings of the 2004 {ACM} {SIGPLAN} symposium on Partial evaluation and semantics-based program manipulation},
	publisher = {{ACM}},
	author = {Armin Rigo},
	year = {2004},
	pages = {15--26}
},

@incollection{carl_friedrich_bolz_back_2008,
	title = {Back to the Future in One Week — Implementing a {S}malltalk {VM} in {PyPy}},
	url = {http://dx.doi.org/10.1007/978-3-540-89275-5_7},
	abstract = {We report on our experiences with the Spy project, including implementation details and benchmark results. Spy is a re-implementation of the Squeak (i.e. Smalltalk-80) {VM} using the {PyPy} toolchain. The {PyPy} project allows code written in {RPython,} a subset of Python, to be translated
to a multitude of different backends and architectures. During the translation, many aspects of the implementation can be
independently tuned, such as the garbage collection algorithm or threading implementation. In this way, a whole host of interpreters
can be derived from one abstract interpreter definition. Spy aims to bring these benefits to Squeak, allowing for greater portability and, eventually, improved performance. The current
Spy codebase is able to run a small set of benchmarks that demonstrate performance superior to many similar Smalltalk {VMs,} but
which still run slower than in Squeak itself. Spy was built from scratch over the course of a week during a joint {Squeak-PyPy} Sprint in Bern last autumn.},
	booktitle = {{Self-Sustaining} Systems},
	author = {Carl Friedrich Bolz and Adrian Kuhn and Adrian Lienhard and Nicholas Matsakis and Oscar Nierstrasz and Lukas Renggli and Armin Rigo and Toon Verwaest},
	year = {2008},
	pages = {123--139}
}

@article{Henglein:1994:DTS:190865.190867,
 author = {Henglein, Fritz},
 title = {Dynamic typing: syntax and proof theory},
 journal = {Sci. Comput. Program.},
 volume = {22},
 issue = {3},
 month = {June},
 year = {1994},
 issn = {0167-6423},
 pages = {197--230},
 numpages = {34},
 url = {http://portal.acm.org/citation.cfm?id=190865.190867},
 doi = {10.1016/0167-6423(94)00004-2},
 acmid = {190867},
 publisher = {Elsevier North-Holland, Inc.},
 address = {Amsterdam, The Netherlands, The Netherlands},
}

